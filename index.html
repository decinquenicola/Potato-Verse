<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Amore infinito!</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><path d='M50 88 C 10 60 0 40 0 25 C 0 10 15 0 35 0 C 45 0 50 5 50 10 C 50 5 55 0 65 0 C 85 0 100 10 100 25 C 100 40 90 60 50 88' fill='orange'/><text x='50' y='55' font-family='serif' font-style='italic' font-weight='bold' font-size='50' fill='black' text-anchor='middle' dominant-baseline='middle'>S</text></svg>">

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* Mirror the video preview */
        #video-element { position: absolute; bottom: 20px; left: 20px; width: 200px; height: 150px; z-index: 2; transform: scaleX(-1); border: 1px solid #444; border-radius: 8px; opacity: 0.6; }
        
        #ui { position: absolute; top: 30px; width: 100%; text-align: center; color: white; z-index: 10; pointer-events: none; }
        
        /* Elegant Title Styling */
        h1 { 
            margin: 0; 
            font-size: 2.5rem; 
            font-family: 'Times New Roman', serif; 
            font-style: italic; 
            letter-spacing: 1px;
            background: linear-gradient(to bottom, #fff, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255, 100, 0, 0.5);
            padding-bottom: 10px;
        }
        
        .controls-container {
    position: fixed;     /* <--- Fissa la posizione rispetto allo schermo */
    bottom: 30px;        /* <--- In basso */
    right: 30px;          /* <--- A sinistra */
    text-align: center;    /* <--- Allinea il testo a sinistra */
    
    background: rgba(0, 0, 0, 0.4);
    padding: 15px 25px;
    border-radius: 30px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(5px);
    z-index: 11;         /* Assicura che stia sopra a tutto */
}

        p { font-size: 0.9rem; color: #ccc; margin: 5px 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .status { color: #ffae00; font-weight: bold; text-transform: uppercase; }
        .icon { font-size: 1.2rem; vertical-align: middle; margin-right: 5px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui">
        <h1>Fin dove si estende l'amore per te, regina mia.</h1>
        <div class="controls-container">
            <p><span class="icon">üñê</span> <b>Apri/chiudi mano destra:</b> Espandi l'Universo!</p>
            <p><span class="icon">üëà</span> <b>Muovi mano sinistra:</b> Cambia colore!</p>
            <p><span class="icon">‚úä</span> <b>Chiudi mano sinistra:</b> Cambia forma!</p>
            <p style="margin-top: 10px; border-top: 1px solid #555; padding-top: 5px;">Forma corrente: <span id="shape-name" class="status">Heart</span></p>
        </div>
    </div>

    <video id="video-element"></video>
    <div id="canvas-container"></div>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 18000; // Increased count for density
    const CANVAS_CONTAINER = document.getElementById('canvas-container');
    const SHAPE_DISPLAY = document.getElementById('shape-name');
    
    // --- THREE.JS SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    CANVAS_CONTAINER.appendChild(renderer.domElement);

    // --- PARTICLE SYSTEM SETUP ---
    const particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);

    // Initialize random positions
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 100;
        targetPositions[i] = positions[i];
        colors[i] = 1;
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Create a texture for the particle (soft glow)
    const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');

    const particlesMaterial = new THREE.PointsMaterial({
        size: 0.3,
        map: sprite,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true,
        opacity: 0.9
    });

    const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particleSystem);

    // --- SHAPE GENERATORS ---
    function getSpherePoint(r) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    }

    const Templates = {
        HEART: (i) => {
            // Heart is the default romantic shape
            const t = Math.random() * Math.PI * 2;
            const u = Math.random() * Math.PI * 2;
            
            // Parametric heart formula
            const x = 16 * Math.pow(Math.sin(u), 3);
            const y = 13 * Math.cos(u) - 5 * Math.cos(2*u) - 2 * Math.cos(3*u) - Math.cos(4*u);
            const z = (Math.random() - 0.5) * 6 * Math.sin(u); 

            // Scale down
            return [x * 0.6, y * 0.6, z * 0.6];
        },
        SPHERE: (i) => {
            const p = getSpherePoint(12);
            return [p.x, p.y, p.z];
        },
        SATURN: (i) => {
            const isRing = Math.random() > 0.4; 
            if (isRing) {
                const angle = Math.random() * Math.PI * 2;
                const rad = 14 + Math.random() * 10; 
                return [
                    Math.cos(angle) * rad, 
                    (Math.random() - 0.5) * 0.8, 
                    Math.sin(angle) * rad
                ];
            } else {
                const p = getSpherePoint(7); 
                return [p.x, p.y, p.z];
            }
        },
        FLOWER: (i) => {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const k = 4; // 8 petals
            const r = 12 * Math.sin(k * theta); 
            
            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta) * Math.sin(phi);
            const z = 6 * Math.cos(phi);
            
            return [x, y, z];
        },
        FIREWORKS: (i) => {
            const p = getSpherePoint(1);
            const explosionScale = Math.random() * 35;
            return [p.x * explosionScale, p.y * explosionScale, p.z * explosionScale];
        }
    };

    let currentShape = 'HEART';
    const shapesList = Object.keys(Templates);
    let shapeIndex = 0;

    function morphTo(shapeKey) {
        currentShape = shapeKey;
        SHAPE_DISPLAY.innerText = shapeKey;
        const generator = Templates[shapeKey];

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const coords = generator(i);
            targetPositions[i * 3] = coords[0];
            targetPositions[i * 3 + 1] = coords[1];
            targetPositions[i * 3 + 2] = coords[2];
        }
    }

    // Initial shape
    morphTo('HEART');

    // --- CONTROL LOGIC ---
    let expansionFactor = 1.0;
    let targetHue = 0.0; // Start Red
    let lastSwitchTime = 0;
    const SWITCH_COOLDOWN = 1500; 

    function updateParticles() {
        const positions = particleSystem.geometry.attributes.position.array;
        const colors = particleSystem.geometry.attributes.color.array;

        const time = Date.now() * 0.001;
        const colorObj = new THREE.Color();
        
        // Dynamic color mixing: Base hue + time variance
        colorObj.setHSL(targetHue, 0.9, 0.6);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;

            // Smooth transition speed
            const lerpSpeed = 0.04; 
            
            // Lerp Position
            positions[ix] += (targetPositions[ix] * expansionFactor - positions[ix]) * lerpSpeed;
            positions[iy] += (targetPositions[iy] * expansionFactor - positions[iy]) * lerpSpeed;
            positions[iz] += (targetPositions[iz] * expansionFactor - positions[iz]) * lerpSpeed;

            // Heartbeat / Pulse effect if Heart
            if(currentShape === 'HEART') {
                const beat = 1 + Math.sin(time * 3) * 0.05;
                positions[ix] *= beat;
                positions[iy] *= beat;
                positions[iz] *= beat;
            }

            // Noise
            positions[ix] += Math.sin(time + positions[iy]) * 0.01;
            positions[iy] += Math.cos(time + positions[ix]) * 0.01;

            // Update Colors
            colors[ix] = colorObj.r;
            colors[iy] = colorObj.g;
            colors[iz] = colorObj.b;
        }

        particleSystem.geometry.attributes.position.needsUpdate = true;
        particleSystem.geometry.attributes.color.needsUpdate = true;
        
        particleSystem.rotation.y += 0.002;
    }

    // --- MEDIAPIPE HANDS SETUP ---
    const videoElement = document.getElementById('video-element');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandedness) {
            
            for (let index = 0; index < results.multiHandLandmarks.length; index++) {
                const landmarks = results.multiHandLandmarks[index];
                const label = results.multiHandedness[index].label; 

                // --- RIGHT HAND (Detected as "Left" in selfie mode) for EXPANSION ---
                if (label === 'Left') { 
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];
                    
                    const distance = Math.sqrt(
                        Math.pow(thumbTip.x - indexTip.x, 2) + 
                        Math.pow(thumbTip.y - indexTip.y, 2)
                    );

                    const clampedDist = Math.max(0.02, Math.min(0.4, distance));
                    const newExpansion = (clampedDist - 0.02) * (7) + 0.5; 
                    expansionFactor += (newExpansion - expansionFactor) * 0.1;
                }

                // --- LEFT HAND (Detected as "Right" in selfie mode) for COLOR & SHAPE ---
                if (label === 'Right') {
                    const wrist = landmarks[0];
                    
                    // X position controls HUE (0.0 - 1.0)
                    targetHue = wrist.x; 
                    
                    // FIST DETECTION logic
                    const tips = [8, 12, 16, 20];
                    let tipsOpen = true;
                    
                    // Check if finger tips are lower (higher y value) than knuckles
                    if (landmarks[8].y > landmarks[6].y && 
                        landmarks[12].y > landmarks[10].y && 
                        landmarks[16].y > landmarks[14].y) {
                        tipsOpen = false;
                    }

                    if (!tipsOpen) {
                        const now = Date.now();
                        if (now - lastSwitchTime > SWITCH_COOLDOWN) {
                            shapeIndex = (shapeIndex + 1) % shapesList.length;
                            morphTo(shapesList[shapeIndex]);
                            lastSwitchTime = now;
                        }
                    }
                }
            }
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    cameraUtils.start();

    // --- ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        updateParticles();
        renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>
